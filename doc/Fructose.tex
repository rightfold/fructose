\documentclass[a4paper]{article}

\usepackage{amsmath}

\usepackage{syntax}
\setlength{\grammarindent}{8em}

\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

\newcommand{\lisp}{\ensuremath{\mathcal{L}\{\lambda isp\}}}

\title{The Fructose Programming Language}

\begin{document}

\maketitle

\begin{abstract}
The Fructose programming language is a lisp-like programming language that translates straightforwardly into ECMAScript. In contrast with ECMAScript, Fructose guarantees referential transparency, and is very strict about which values can go where.
\end{abstract}

\section{The Reader}

The reader is a program that parses a textual representation of a value and returns that value. The reader reads values according to the following grammar shown in figure \ref{fig:readergrammar}.

\begin{figure}[h]
\label{fig:readergrammar}
\caption{The reader grammar. Rules with capitalized names ignore surrounding whitespace, where whitespace is defined by rule $\{ \langle space \rangle \}$}
\begin{grammar}
<Value> ::= <Atom>
\alt <Boolean>
\alt <Number>
\alt <String>
\alt <Array>

<Atom> ::= \{ {\it any code point in Unicode category {\bf L}, {\bf Pc}, {\bf Pd}, or {\bf S}} \}

<Boolean> ::= "#t" | "#f"

<Number> ::= [ "-" ] <digit> \{ <digit> \} [ "." <digit> \{ <digit> \} ]
\alt "0x" <hex-digit> \{ <hex-digit> \}

<String> ::= "\"" \{ <char> \} "\""

<char> ::= {\it any code point except "\"" and "\\"}
\alt "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\\\" | "\\'" | "\\\"" | "\\?"
\alt "\\u" <hex-digit> <hex-digit> <hex-digit> <hex-digit>

<Array> ::= "(" \{ <Value> \} ")"

<letter> ::= "a" .. "z" | "A" .. "Z"

<digit> ::= "0" .. "9"

<hex-digit> ::= "0" .. "9" | "a" .. "f" | "A" .. "F"

<space> ::= {\it any code point with Unicode property {\bf WSpace=Y}}
\alt ","

\end{grammar}
\end{figure}

\section{The Compiler}

The compiler is a program that translates a value into a term in the language \lisp, shown in figure \ref{fig:lisp}. \lisp\ extends the untyped $\lambda$-calculus with multi-parameter functions, quotations, and conditionals. This translation is rather straightforward:

$$
\begin{aligned}
\mu\;\mathtt{x} &= x && \text{where $\mathtt{x} : \langle Atom \rangle$} \\
\mu\;\hbox{\texttt{\#}}\mathtt{t} &= \mathtt{true} \\
\mu\;\hbox{\texttt{\#}}\mathtt{f} &= \mathtt{false} \\
\mu\;v &= v && \text{where $v : \langle Number \rangle$} \\
\mu\;v &= v && \text{where $v : \langle String \rangle$} \\
\mu\;\mathtt{(} e_1\;e_i\;\dots \mathtt{)} &= (\mu\;e_1)(\mu\;e_i, \dots) \\
\mu\;\mathtt{(} \mathtt{fn}\;(\mathtt{x}_i\; \dots)\;e \mathtt{)} &= \lambda(x_i, \dots).\;\mu\;e && \text{where $\mathtt{x}_i : \langle Atom \rangle$} \\
\mu\;\mathtt{(} \mathtt{quote}\;v \mathtt{)} &= v \\
\mu\;\mathtt{(} \mathtt{if}\;e_1\;e_2\;e_3 \mathtt{)} &= \mathtt{if}\;\mu\;e_1\;\mathtt{then}\;\mu\;e_2\;\mathtt{else}\;\mu\;e_3 \\
\mu\;\mathtt{(} \mathtt{let}\;\mathtt{x}\;e_1\;e_2 \mathtt{)} &= (\lambda(x).\;\mu\;e_2)(\mu\;e_1) && \text{where $\mathtt{x} : \langle Atom \rangle$} \\
\end{aligned}
$$

\begin{figure}[h]
\label{fig:lisp}
\caption{\lisp.}

{\bf Syntax}

\begin{tabular}{ll}
$x$ & Variable \\
$v$ ::= & Value \\
\hspace{1em} $\mathtt{true}$ & \hspace{1em} Boolean true \\
\hspace{1em} $\mathtt{false}$ & \hspace{1em} Boolean false \\
\hspace{1em} $w$ & \hspace{1em} Non-Boolean \\
$e$ ::= & Term \\
\hspace{1em} $x$ & \hspace{1em} Variable \\
\hspace{1em} $\lambda(x_i, \dots).\;e$ & \hspace{1em} Lambda \\
\hspace{1em} $e(e_i, \dots)$ & \hspace{1em} Application \\
\hspace{1em} $\mathtt{if}\;e_1\;\mathtt{then}\;e_2\;\mathtt{else}\;e_3$ & \hspace{1em} Conditional \\
\hspace{1em} $v$ & \hspace{1em} Quotation \\
\end{tabular}

\hrulefill

{\bf Reduction}

$$\frac{}{x \rightarrow x}$$
$$\frac{}{\lambda(x_i, \dots).\;e \rightarrow \lambda(x_i, \dots).\;e}$$
$$\frac{e_1 \rightarrow \lambda(x_i, \dots).\;e_1' \quad e_i \rightarrow e_i', \dots \quad e_1'[e_i' / x_i, \dots] \rightarrow e_2}{e_1(e_i, \dots) \rightarrow e_2}$$
$$\frac{e_1 \rightarrow \mathtt{true} \quad e_2 \rightarrow e_2'}{\mathtt{if}\;e_1\;\mathtt{then}\;e_2\;\mathtt{else}\;e_3 \rightarrow e_2'}$$
$$\frac{e_1 \rightarrow \mathtt{false} \quad e_3 \rightarrow e_3'}{\mathtt{if}\;e_1\;\mathtt{then}\;e_2\;\mathtt{else}\;e_3 \rightarrow e_3'}$$
$$\frac{}{v \rightarrow v}$$

\end{figure}

\section{The Code Generator}

The code generator is a program that translates a \lisp\ term into an ECMAScript program, such that the resulting ECMAScript program exhibits the same reduction rules.

\end{document}
